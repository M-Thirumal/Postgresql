{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PostgreSQL Tutorial","text":""},{"location":"#terminal-access","title":"Terminal Access","text":"<ul> <li>Run <code>.sql</code> file in terminal</li> </ul>"},{"location":"#pgmodeler","title":"PgModeler","text":"<p>Install PgModeler on Ubuntu</p>"},{"location":"#backup","title":"Backup","text":""},{"location":"#pgbackrest","title":"PgBackRest","text":"<ul> <li>PgBackRest</li> </ul>"},{"location":"#pgadmin","title":"PgAdmin","text":""},{"location":"#disaster-recovery","title":"Disaster Recovery","text":"<ul> <li>Definitions</li> </ul>"},{"location":"#tuning","title":"Tuning","text":""},{"location":"Backup%20Restore/Types%20of%20Backup/","title":"Types of Backup","text":"<ol> <li> <p>Difference between <code>physical and logical backup</code>?</p> <p><code>Logical backup</code> is using SQL statements. Export using exp tool is logical.</p> <p><code>Physical backup</code> is copying the data files either when the database is up and running <code>(HOT BACKUP)</code> or when the database is shutdown <code>(COLD BACKUP)</code></p> <ul> <li> <p>In other words,</p> <p><code>Physical backup</code> is to copy for backing up all the physical files that belongs to database.(like data files,control files,log files, executables etc). <code>Logical backup</code>, you don't take the copies of any physical things,you only extract the data from the data files into dump files.(ex : using export )</p> </li> </ul> </li> </ol>"},{"location":"Backup%20Restore/Types%20of%20Backup/#backups-","title":"Backups:-","text":""},{"location":"Backup%20Restore/backup%20restore/","title":"Backup restore","text":""},{"location":"Backup%20Restore/backup%20restore/#to-take-back-up","title":"To take back up","text":"<pre><code>sudo -u postgres pg_dump {database_name_to_backup} &gt; {backup_file_name}.sql\n</code></pre>"},{"location":"Backup%20Restore/backup%20restore/#restore-login-as-postgres-user","title":"Restore (Login as postgres user)","text":"<p>For <code>Mac OS</code> go to <code>/Applications/Postgres.app/Contents/Versions/latest/Bin</code></p> <pre><code>./psql {database_name_to_backup} &lt; /Users/Thirumal/Documents/{database_name_to_backup}.sql\n</code></pre> <p>For <code>Ubuntu</code>, login with <code>postgres</code> user</p> <pre><code>sudo su postgres\n\n# Create database\npsql\ncreate {database_name};\n\\q\n\npsql -U {userName} {databaseName} &lt; {backup-file}.sql\n\npsql -U postgres {database_name_to_backup} &lt; {database_name_to_backup}.sql\n</code></pre>"},{"location":"Cluster/Commands/","title":"Commands","text":""},{"location":"Cluster/Commands/#list-all-cluster","title":"List all cluster","text":"<pre><code>pg_lsclusters\n</code></pre>"},{"location":"Cluster/Commands/#start-cluster","title":"Start cluster","text":"<pre><code>sudo pg_ctlcluster 13 main start\n</code></pre>"},{"location":"Cluster/Commands/#stop-cluster","title":"Stop cluster","text":"<pre><code>sudo pg_ctlcluster 13 main stop\n</code></pre>"},{"location":"Cluster/Commands/#status-of-cluster","title":"Status of Cluster","text":"<pre><code>systemctl status postgresql@13-main.service\n</code></pre>"},{"location":"Cluster/Commands/#drop-cluster","title":"Drop Cluster","text":"<pre><code>pg_dropcluster\n\nEg: sudo pg_dropcluster 13 main --stop\n</code></pre>"},{"location":"Cluster/Commands/#upgrade-cluster","title":"Upgrade cluster","text":"<pre><code>sudo pg_upgradecluster 13 main\n</code></pre>"},{"location":"DML/Delete%20all%20not%20referenced%20%28by%20foreign%20key%29%20records%20from%20a%20table/","title":"Delete all not referenced (by foreign key) records from a table","text":"<pre><code>DELETE FROM table_1 WHERE table_1_pk_id NOT IN (SELECT table_1_pk_id FROM table_2)\n</code></pre>"},{"location":"DML/How%20to%20Identify%20Duplicate%20Rows/","title":"How to Identify Duplicate Rows?","text":"<pre><code>select * from (\n  SELECT party_relationship_id,\n  ROW_NUMBER() OVER(PARTITION BY icms_case_id, l_party_id, r_party_id, relationship_cd ORDER BY party_relationship_id asc) AS Row\n  FROM icms.party_relationship\n) dups\nwhere \ndups.Row &gt; 1\n</code></pre> <p>Delete the duplication rows</p> <pre><code>delete from icms.party_relationship where party_relationship_id in (select party_relationship_id from (\n  SELECT party_relationship_id,\n  ROW_NUMBER() OVER(PARTITION BY icms_case_id, l_party_id, r_party_id, relationship_cd ORDER BY party_relationship_id asc) AS Row\n  FROM icms.party_relationship\n) dups\nwhere \ndups.Row &gt; 1)\n</code></pre>"},{"location":"Docker/Single%20Docker/","title":"Single Docker","text":""},{"location":"Docker/Single%20Docker/#get-image","title":"Get Image","text":"<pre><code>docker pull postgres\n</code></pre>"},{"location":"Docker/Single%20Docker/#create-run-container","title":"Create &amp; Run Container","text":"<pre><code>docker run --name postgres -e POSTGRES_PASSWORD='thirumal' -d -p 5432:5432 postgres\n</code></pre>"},{"location":"Docker/Single%20Docker/#connect-to-postgresql-container","title":"Connect to PostgreSQL container","text":"<pre><code>docker exec -it postgres /bin/bash\n</code></pre>"},{"location":"Drop/drop-database/","title":"Drop database","text":"<p>As of version 9.5, you cannot drop a Postgres database while clients are connected to it, using only <code>dropdb</code> utility - which is a simple wrapper around <code>DROP DATABASE</code> server query.</p> <p>Quite robust workaround follows:</p> <p>Connect to your server as superuser, using <code>psql</code> or other client. Do not use the database you want to drop.</p> <pre><code>psql -h localhost postgres postgres\n</code></pre> <p>Now using plain database client you can force drop database using three simple steps:</p> <ol> <li> <p>Make sure no one can connect to this database. You can use one of following methods (the second seems safer, but works only for non-superusers).</p> <pre><code>/* Method 1: update system catalog */\nUPDATE pg_database SET datallowconn = 'false' WHERE datname = 'mydb';\n\n/* Method 2: use ALTER DATABASE. Superusers still can connect! */\nALTER DATABASE mydb CONNECTION LIMIT 1;\n</code></pre> </li> <li> <p>Force disconnection of all clients connected to this database, using <code>pg_terminate_backend</code>.</p> </li> </ol> <p>For Postgres versions &gt;= 9.2 change <code>procpid</code> to <code>pid</code>:</p> <pre><code>    SELECT pg_terminate_backend(pid)\n    FROM pg_stat_activity\n    WHERE datname = 'mydb';\n</code></pre> <ol> <li>Drop it.<pre><code>DROP DATABASE mydb;\n</code></pre> </li> </ol> <p>Step 1 requires superuser privileges for the 1st method, and db owner privileges for the 2nd one. Step 2 requires superuser privileges. Step 3 requires database owner privilege.</p>"},{"location":"Extension/Extension/","title":"Extension","text":"<p>To list all available extensions:- </p> <pre><code>select * from pg_available_extensions; \n</code></pre> <p>To list installed extension of the selected database  </p> <p><pre><code>SELECT * FROM pg_extension;\n</code></pre> OR  <pre><code>\\dx\n</code></pre></p>"},{"location":"Extension/Extension/#install","title":"Install","text":""},{"location":"Extension/Extension/#syntax","title":"Syntax","text":"<pre><code>CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"btree_gist\";\n</code></pre>"},{"location":"Installation/installation/","title":"Installation","text":"<p>[Refer -&gt; PostgreSQL Installation] (https://github.com/m-thirumal/installation_guide/blob/master/PostgreSQL/Install_PostgresQL_in_Ubuntu.md)</p>"},{"location":"Physical_location/table_location/","title":"Table location","text":""},{"location":"Physical_location/table_location/#physical-location-of-table","title":"Physical location of table","text":"<p><code>pg_relation_filepath</code> which returns the first heap file segment with a relative path to the environment variable <code>PGDATA</code></p> <pre><code>postgres=# SELECT pg_relation_filepath('table_name');\n</code></pre>"},{"location":"Physical_location/table_location/#the-extension-for-page","title":"The extension for Page","text":"<p>The <code>pageinspect</code> extension provides the functions that allow you to inspect the contents of database pages at a low level, which is very useful for debugging purposes. Here are the main functions provided by pageinspect. To use this extension, you have to install it first, and then add it to your PG server. For example,</p> <pre><code>postgres=# create extension pageinspect;\nCREATE EXTENSION\n</code></pre>"},{"location":"Q%20%26%20A/1/","title":"1","text":"<ol> <li>Whether a DDL is going to rewrite the table (and in some cases may need ~ 2x disk space)?</li> </ol> <p>For a brief background, each regular table in Postgres stores data in one or more files, each of which is referenced in the postgres catalog with a <code>relfilenode</code>.</p> <pre><code>It depends on the following\n\n* Postgresql Version\n* Data type of column\n</code></pre> <ol> <li>What DDLs would block concurrent workload?</li> </ol>"},{"location":"Recovery/Theory/","title":"Theory","text":""},{"location":"Recovery/Theory/#recovery-explaination","title":"Recovery Explaination","text":""},{"location":"Recovery/Theory/#rto","title":"RTO","text":"<p>RTO - Recovery time objective (RTO) is the maximum bearable length of time that an application or a service can be down after a disaster without causing any significant damage to the business.</p> <p></p>"},{"location":"Recovery/Theory/#rto-vs-rpo","title":"RTO VS RPO","text":"<p>RPO</p>"},{"location":"Rename/rename_database/","title":"Rename database","text":""},{"location":"Rename/rename_database/#terminate-all-the-connections-to-the-database","title":"Terminate all the connections to the database","text":"<pre><code>    SELECT\n        pg_terminate_backend (pid)\n    FROM\n        pg_stat_activity\n    WHERE\n        datname = 'db';\n</code></pre>"},{"location":"Rename/rename_database/#rename-database","title":"Rename database","text":"<pre><code>ALTER DATABASE db RENAME TO newdb;\n</code></pre>"},{"location":"Roles%20%26%20Group/Get%20Members%20role%20%26%20permissions/","title":"Get Members role & permissions","text":""},{"location":"Roles%20%26%20Group/Get%20Members%20role%20%26%20permissions/#preparing-users-and-roles","title":"Preparing users and roles","text":"<pre><code>CREATE USER a;\nCREATE USER b;\nCREATE ROLE c LOGIN;\nCREATE ROLE d LOGIN;\nCREATE ROLE e LOGIN;\nCREATE ROLE f LOGIN;\n</code></pre> <p>The important thing to note here is that <code>users</code> and <code>roles</code> are basically the same thing.</p> <p>The main difference is that a <code>role</code> is always <code>NOLOGIN</code> while a <code>user</code> is <code>LOGIN</code>. However, if you want a role to be able to log in, you can simply mark it as <code>login</code>.</p> <p>Otherwise, there is no difference. Behind the scenes, roles and users are all the same.</p> <p>We can now assign roles to other roles (= users), using simple GRANT statements: <pre><code>GRANT c TO a;\nGRANT d TO c;\nGRANT e TO c;\nGRANT f TO d;\n</code></pre></p>"},{"location":"Roles%20%26%20Group/Get%20Members%20role%20%26%20permissions/#query-to-get-all-the-roles","title":"Query to get all the Roles","text":"<p>In <code>PostgreSQL</code>, all object ids below <code>16384</code> are <code>reserved for system objects</code></p> <p><code>pg_authid</code> contains a list of all roles, as well as some additional information (can log in, is superuser yes / no, etc.). What is noteworthy here is that each user has an internal number (= object id) which identifies the role.</p> <p><code>SELECT oid, rolname, rolcanlogin FROM pg_authid WHERE oid &gt; 16384;</code></p> <p><code>pg_auth_members</code> basically knows which role is assigned to which other role. It is a simple role / member list which contains object ids to identify our users</p> <p><code>SELECT * FROM pg_auth_members WHERE roleid &gt; 16384;</code></p>"},{"location":"Roles%20%26%20Group/Get%20Members%20role%20%26%20permissions/#resolving-users-and-role-membership-in-postgresql","title":"Resolving users and role membership in PostgreSQL","text":"<p><code>WITH RECURSIVE x AS (   SELECT member::regrole,          roleid::regrole AS role,          member::regrole || ' -&gt; ' || roleid::regrole AS path   FROM pg_auth_members AS m   WHERE roleid &gt; 16384   UNION ALL   SELECT x.member::regrole,          m.roleid::regrole,          x.path || ' -&gt; ' || m.roleid::regrole  FROM pg_auth_members AS m     JOIN x ON m.member = x.role   )   SELECT member, role, path   FROM x   ORDER BY member::text, role::text;</code></p>"},{"location":"Roles%20%26%20Group/ROLE/","title":"Roles","text":"<p><code>PostgreSQL</code> uses roles to represent user accounts. It doesn\u2019t use the user concept like other database systems.</p> <p>Typically, <code>roles</code> can log in are called <code>login roles</code>. They are equivalent to users in other database systems.</p> <p>Role\u2019s are the other way to manage database access permissions.</p> <ul> <li>It can be standard database users (Role).</li> <li>It can be database user group (Group Role).</li> <li>A role can be a member of another role (Role Membership).</li> </ul> <p>When <code>roles</code> contain <code>other roles</code>, they are call <code>group roles</code></p>"},{"location":"Roles%20%26%20Group/ROLE/#create-role","title":"CREATE ROLE","text":"<pre><code>    CREATE ROLE role_name;\n</code></pre> <p>When you create a role, it is valid in all databases in the database server (or cluster).</p> <p>Eg:</p> <pre><code>    CREATE ROLE Thirumal;\n</code></pre> <p>OR</p> <p>With more than one Membership</p> <pre><code>    CREATE ROLE role1 WITH superuser login password 'thirumal';\n</code></pre>"},{"location":"Roles%20%26%20Group/ROLE/#rename-role","title":"RENAME ROLE","text":"<pre><code>    ALTER USER {Existing_role} RENAME TO \"{New Role name}\";\n\n    ALTER USER Thirumal RENAME TO \"Thirumal M\";\n</code></pre>"},{"location":"Roles%20%26%20Group/ROLE/#list-roles","title":"LIST Roles","text":"<pre><code>    &gt; \\du\n\n    OR\n\n    SELECT rolname FROM pg_roles;\n</code></pre>"},{"location":"Roles%20%26%20Group/ROLE/#_1","title":"Roles","text":"<p>With <code>grant</code>, access privileges are determined. There are two types.</p> <ul> <li>Privileges in database objects</li> <li>Membership with privilege</li> </ul> <p>SELECT, INSERT, UPDATE, DELETE, TRUNCATE, ALL PRIVILEGES etc. privileges can be grant.</p> <p>List all privilege</p> <pre><code>    &gt; \\dp\n</code></pre>"},{"location":"Roles%20%26%20Group/ROLE/#role-attributes","title":"Role attributes","text":"<pre><code>The attributes of a role define privileges for that role including `login`, `superuser`, `database creation`, `role creation`, `password`, etc\n\n    CREATE ROLE name WITH option;\n\n\n`option` can be `SUPER, CREATEDB, CREATEROLE, etc`.\n</code></pre> <p>Example:-</p> <pre><code>CREATE ROLE Thirumal;\n\nGRANT SELECT, etc. ON ALL TABLES IN SCHEMA public TO \"Thirumal\";\n</code></pre>"},{"location":"Roles%20%26%20Group/ROLE/#revoke","title":"Revoke","text":"<pre><code>REVOKE writeaccess FROM Thirumal;\n\nREVOKE ALL ON accommodation_transaction FROM PUBLIC;\n</code></pre>"},{"location":"Terminal/Run%20SQL/","title":"Run SQL","text":""},{"location":"Terminal/Run%20SQL/#run-sql-files","title":"Run SQL files","text":"<ol> <li>Make sure <code>PSQL</code> is available</li> </ol> <pre><code>psql -d \"dbname='lookup' user='postgres' password='thirumal' host='localhost'\" -f cities.sql\n</code></pre>"},{"location":"Troubleshoot/Postgres%20is%20up%20but%20cluster%20is%20not%20running/","title":"Failed to start PostgreSQL Cluster main when booting","text":"<ol> <li> <p>Check the cluster Status</p> <p>pg_lsclusters</p> <p>Cluster Down:</p> <p>Ver Cluster Port Status Owner    Data directory              Log file    13  main    5432 down   postgres /var/lib/postgresql/13/main /var/log/postgresql/postgresql-13-main.log</p> </li> <li> <p>Check &amp; change the permission if it's not <code>700</code>,</p> <p>sudo chmod 700 -R /var/lib/postgresql/13/main/</p> <p>$ ls -l /var/lib/postgresql/13/main/    drwx------ 19 postgres postgres</p> </li> <li> <p>Then, restart PostgreSQL server</p> <p>sudo -i -u postgres</p> <p>/usr/lib/postgresql/13/bin/pg_ctl restart -D /var/lib/postgresql/13/main</p> </li> </ol>"},{"location":"Troubleshoot/%E2%80%9CBinaries%20not%20found%E2%80%9D%20error%20in%20Postgres.app/","title":"\u201cBinaries not found\u201d error in Postgres.app","text":"<ol> <li> <p>Remove the existing server and Create new server.</p> </li> <li> <p>To do that, click on the side-bar in the <code>Postgres.app</code></p> </li> </ol>"},{"location":"Tuning/Tuning_for_High_Write_Workload/","title":"Tuning for High Write Workload","text":""},{"location":"Tuning/Tuning_for_High_Write_Workload/#tuning-postgresql-for-high-write-workload","title":"Tuning PostgreSQL for High Write workload","text":"<ol> <li>Use <code>WAL</code> Compression</li> <li>Increase <code>max_wal_size</code></li> <li>Hot Update</li> <li> <p>Remove Randomness </p> <p>Example: UUID is randomness reduces the write performance in <code>B-Tree</code></p> <p>What to do if  <code>PRIMARY KEY</code> is UUID?</p> <pre><code>Prefix UUID with date. YYYYMMDDHH24\n</code></pre> <ol> <li>Vacuuming  </li> </ol> </li> </ol>"},{"location":"connection/mac/Basic/","title":"Basic","text":"<p>1) To Login with postgres use the following command</p> <pre><code>     cd /Applications/Postgres.app/Contents/Versions/latest/bin/\n     ./psql postgres\n</code></pre> <p>2) To get/show datasbse config file us the following commands</p> <pre><code>    SHOW hba_file;\n    SHOW config_file;\n</code></pre> <p>3) </p>"},{"location":"constraint/Fk%20Array%20Element/","title":"Fk Array Element","text":"<p>Patch is available to add reference to integer[] to FK table column</p>"},{"location":"hot_update/hot_update/","title":"Hot update","text":""},{"location":"hot_update/hot_update/#hot-heap-only-tuple-update","title":"Hot (Heap Only Tuple) Update","text":"<p>Update the row - where there is no update on index column.</p> <p></p> <p>#### How to Track?</p> <pre><code>select n_tup_upd, n_tup_hot_upd from pg_stat_all_tables where relname = 'table_name'\n</code></pre> <p>### How to improve High write workload</p> <p>Avoid updating indexed column.</p>"},{"location":"partition/0.intro/","title":"0.intro","text":""},{"location":"partition/0.intro/#constraint-on-table-size","title":"Constraint on table size","text":"<ul> <li>The maximum table size in PostgreSQL is <code>32TB</code></li> </ul>"},{"location":"partition/0.intro/#how-should-the-table-be-partitioned","title":"How Should The Table Be Partitioned?","text":"<ul> <li>The keys for access patterns are in the <code>WHERE clause</code> and <code>JOIN</code> conditions. Any time a query specifies columns in the WHERE and JOIN clauses, it tells the database <code>This is the data I want</code></li> </ul>"},{"location":"pgmodeler/build_pgmodeler_from_source_mac/","title":"Build pgmodeler from source mac","text":""},{"location":"pgmodeler/build_pgmodeler_from_source_mac/#build-pgmodeler-from-the-source-for-mac","title":"Build pgmodeler from the source for MAC","text":""},{"location":"pgmodeler/build_pgmodeler_from_source_mac/#clone","title":"Clone","text":"<p><code>git clone https://github.com/pgmodeler/pgmodeler.git</code></p> <p><code>cd pgmodeler</code></p>"},{"location":"pgmodeler/build_pgmodeler_from_source_mac/#build","title":"Build","text":"<ol> <li>Install PostgreSQL</li> <li>Install Xcode</li> <li>Install libxml2, qt &amp; libpq</li> </ol> <pre><code>brew install qt libxml2 libpq\n</code></pre> <p>And change the installation path in 'pgmodeler.pri', something similar to the following configuration <pre><code>macx {\n  PGSQL_LIB = /Applications/Postgres.app/Contents/Versions/12/lib/libpq.dylib\n  PGSQL_INC = /Applications/Postgres.app/Contents/Versions/12/include\n  XML_INC = /usr/local/Cellar/libxml2/2.9.10_1/include/libxml2\n  XML_LIB = /usr/local/Cellar/libxml2/2.9.10_1/lib/libxml2.dylib\n  INCLUDEPATH += $$PGSQL_INC $$XML_INC\n}\n</code></pre> then, run the below command to build</p> <p><code>/usr/local/opt/qt/bin/qmake -r pgmodeler.pro</code></p>"},{"location":"pgmodeler/build_pgmodeler_from_source_mac/#install","title":"Install","text":"<p>Run the below command to install pgModeler in '/Application'</p> <p><code>make &amp;&amp; make install</code></p> <p>Go to application and select pgmodeler</p> <p>Enjoy !!!</p> <p></p>"},{"location":"pgmodeler/build_pgmodeler_from_source_ubuntu/","title":"Build PgModeler from source =&gt; Ubuntu","text":""},{"location":"pgmodeler/build_pgmodeler_from_source_ubuntu/#installing-libraries-dependencies","title":"Installing libraries (Dependencies)","text":"<pre><code> 1.  sudo apt-get install build-essential\n 2.  sudo apt-get install git\n 3.  sudo apt-get install qtcreator\n 4.  sudo apt-get install qt5-default \n 5.  sudo apt-get install qt5-qmake\n 6.  sudo apt-get install libpq5\n 7.  sudo apt-get install libxml2\n 8.  sudo apt-get install pkg-config\n 9.  sudo apt-get install xml2\n 10. sudo apt-get install libxml2-dev\n 11. sudo apt-get install libpq-dev\n 12. sudo apt-get install libqt5svg5-dev\n</code></pre> <p>or install all dependencies in one command line</p> <pre><code>sudo apt-get install build-essential git qtcreator qt5-default qt5-qmake libpq5 libxml2 pkg-config xml2 libxml2-dev libpq-dev libqt5svg5-dev\n</code></pre>"},{"location":"pgmodeler/build_pgmodeler_from_source_ubuntu/#getting-the-source","title":"Getting the source","text":"<p>Clone the PgModeler from github https://github.com/pgmodeler/pgmodeler.git</p> <pre><code>git clone https://github.com/pgmodeler/pgmodeler.git\ncd pgmodeler\n</code></pre>"},{"location":"pgmodeler/build_pgmodeler_from_source_ubuntu/#build-the-application","title":"Build the application","text":"<p>Once everything is prepared, you can compile and install pgmodeler using the following commands</p> <pre><code>qmake pgmodeler.pro\nmake\nsudo make install\n</code></pre> <p>The binary will be available in /usr/local/bin/</p>"},{"location":"pgmodeler/build_pgmodeler_from_source_ubuntu/#open-pgmodeler","title":"Open PgModeler","text":"<p>Just type the below command in terminal</p> <pre><code>pgmodeler\n</code></pre> <p>Tested with Ubuntu-20.04 Enjoy !!!</p> <p></p>"},{"location":"wal/Intro/","title":"Intro","text":""},{"location":"wal/Intro/#write-ahead-log-wal","title":"Write Ahead Log (WAL)","text":"<p>WAL is the mechanism that PostgreSQL uses to ensure that no committed changes are lost. </p> <p>Transactions are written sequentially to the WAL and a transaction is considered to be committed when those writes are flushed to disk. </p> <p>Afterwards, a background process writes the changes into the main database cluster files (also known as the heap). In the event of a crash, the WAL is replayed to make the database consistent.</p> <p>WAL is conceptually infinite but in practice is broken up into individual 16MB files called segments. </p> <p>WAL segments follow the naming convention 0000000100000A1E000000FE where the first 8 hexadecimal digits represent the timeline and the next 16 digits are the logical sequence number (LSN).</p>"}]}